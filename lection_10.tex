% !TeX spellcheck = russian_english
% !TeX encoding = UTF-8
\documentclass[a4paper, fleqn]{article}

\usepackage{indentfirst} % Красная строка
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[russian]{babel} % руссификация
\usepackage{amssymb} % дополнительные символы
\usepackage{textcomp} % дополнительные текстовые символы
\usepackage{amsmath} % матрицы
%\usepackage{pdfpages}
%\usepackage{pgfplots}
%\usepackage{pgfplotstable}
\usepackage{listings}
% листинги
\lstset{language=Python, tabsize=4, language=Python}


\textwidth = 16 cm
\oddsidemargin= 0 cm
\evensidemargin= 1 cm


% \abovedisplayskip = 0 pt %.2\abovedisplayskip
% \belowdisplayskip = .2\belowdisplayskip
% \abovedisplayshortskip=.2\abovedisplayshortskip
% \belowdisplayshortskip=.2\belowdisplayshortskip
% \topsep= 0 pt

% \setlength{\mathindent}{1.2 cm}
% \setlength{\topsep}{0 pt}
% \setlength{\abovedisplayskip}{0 pt}

% \clubpenalty = 5000 % запрет висячих строк
% \widowpenalty = 5000
\binoppenalty=10000
\relpenalty=10000

% собственные команды и окружения

\newenvironment{example}[1][]{\medskip \noindent \textbf{Пример. #1}\par \nopagebreak}{\medskip \par} % окружение-"пример"


\title{Лекция \textnumero\,10}
% {\huge \vspace{3 cm}}}

\author{Т.\,Ф. Хирьянов}

\date{}

\begin{document}
	\maketitle
	
\section*{Динамическое программирование}

% мой листинг
%\texttt{
%	\begin{tabbing}
%		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
%		р
%	\end{tabbing}
%	}

%04:00

У рекурсивной функции вычисления числа Фибоначчи очень большая асимптотическая сложность ($2^n$). При этом для человека это не слишком сложная задача при наличии листка бумаги и ручки. Это отличие обусловлено тем, что человек, начинает подсчет не с числа с номером $n$, а с первого числа и идет по порядку. Тем самым он идет от простой задачи к сложной, а не наоборот, как реализованно в рекурсивном алгоритме. В этом заключается подход динамического программирования. В качестве примера рассмотрим решение той же задачи с его помощью. 

Функция \texttt{fib}, получающая на вход номер числа Фибоначчи, который необходимо вывести, создает список необходимого размера, начинающийся с 0 и 1. Затем в цикле находятся последовательно все числа Фибоначчи, начиная со второго и заканчивая $n$. Для этого используется очевидная рекуррентная формула \texttt{F[i] = F[i - 1] + F[i - 2]}.

\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def fib(n):\\
		\> F = [0, 1] + [0]*(n - 1)\\
		\> for i in range(2, n + 1):\\
		\> \> F[i] = F[i - 1] + F[i - 2]\\
		\> return F[n]
	\end{tabbing}
}

Может показаться, что данное решение значительно проигрывает рекурсивному по объему используемой памяти, однако это не так, потому что при каждом вызове рекурсивной функции на стек кладется текущий номер числа и адрес возврата. Поэтому количество необходимой памяти в процессе работы программы становится пропорционально $2n$. В случае динамического программирования памяти требуется меньше. Можно даже улучшить программу, запоминая только последние два числа. Время выполнения программы также пропорционально $n$. 





\subsection*{Кузнечик}

% 10:15
Допустим, что кузнечик прыгает от нулевой клетки до клетки с номером $n$. При этом за один прыжок, он может преодолеть одну или две клетки. Необходимо посчитать количество возможных траекторий. Допустим, что в клетку с номером $i-2$ можно попасть $N_{i-2}$ способами, а в клетку с номером $i-1$ -- $N_{i-1}$ способами, тогда очевидно, что количество траекторий до i-й клетки равно $N_{i-1} + N_{i-2}$. Используя этот факт и решение задачи о нахождении n-ого числа Фибоначчи, получим требуемый алгоритм, в котором вычисляются количества траекторий до каждой i-й клетки и хранятся последовательно в списке K. 
% 14:40
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		K = [0, 1] + [0]*(n - 1)\\
		for i in range(2, n + 1):\\
		\> \> K[i] = K[i - 1] + K[i - 2]\\
		print(K[n])
	\end{tabbing}
}
По своей сути это очень похожие задачи.
% 16:30
\subsection*{Количество траекторий с запрещенными клетками}

Можно усложнить предыдущую задачу, запретив кузнечику прыгать на некоторые клетки. Для этого нужно создать специальный список запрещенных клеток, например, присвоив i-й клетке значение 0, если в нее можно прыгнуть и 1, если это запрещено. Далее, как и в предыдущей программе, создается массив К, в котором для каждой клетки хранится количество траекторий до нее. Отличие состоит лишь в том, что если i-я клетка запрещенная, то количество траекторий до нее равно нулю.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		Denied = [0, 0, 1, 0, 0, 1, 0, 0, ... 1, 0, 0]\\
		n = int(input())\\
		K =[0, 1] + [None]*(n - 1)\\
		for i in range(2, n + 1):\\
		\> if Denied[i]:\\
		\> \> K[i] = 0\\
		\> else:\\
		\> \> K[i] = K[i - 1] + K[i - 2]
	\end{tabbing}
}

% 22:50
\subsection*{Задача о минимальной стоимости}

% 29:30
Допустим условно, что за нахождение в каждой клетке взимается определенная сумма денег. Необходимо определить минимальную сумму, которую требуется заплатить, чтобы добраться до нужной клетки. Для этого по аналогии с предыдущим примером задается список цен нахождения в каждой клетке Price, и список С, в который для каждой клетки будет задаваться минимальная стоимость ее достижения. Очевидно, что стоимость достижения i-й клетки будет равна сумме стоимости нахождения в ней и минимальной из стоимостей достижения соседних клеток. 

В данной задаче возникает вопрос, какая именно траектория обладает наименьшей стоимостью. Для этого можно заполнять массив Path номерами клеток, через которые проходила искомая траектория. При этом нужно двигаться с конца, каждый раз выбирая ту клетку из двух, стоимость прибывания в которой меньше. Полученный массив Path в конце работы программы следует перевернуть. 
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		Price = [10, 20, 5, 3, ...]\\
		n = int(input())\\
		C = [0]*(n + 1)\\
		C[0] = Price[0]\\
		C[1] = C[0] + Price[1]\\
		for i in range(2, n + 1):\\
		\> C[i] = Price[i] + min(C[i - 1], C[i - 2])\\
		print(C[n])\\
		\\
		Path = [n]\\
		while Path[-1] != 0:\\
		\> i = Path[-1]\\
		\> if C[i - 1] < C[i - 2]:\\
		\> \> Path.append(i - 1)\\
		\> else:\\
		\> \> Path.append(i - 2)\\
		Path = Path[::-1]
	\end{tabbing}
}

% перерыв

% король
% 00:00

% 03:30

\subsection*{Исполнитель король}

Похожим исполнителем является \emph{король}, который может шагать по шахматной доске вниз, вправо и по диагонали (однако при этом он не может ходить назад). Фигура начинает шагать из верхнего левого угла. Можно поставить аналогичную задачу нахождения кратчайшей траектории до конкретной клетки. Для этого необходимо сначала обработать клетки на верхней и левой границах. Создадим двумерный список К, размера $n\times m$ заполненный нулями. Затем с помощью двух циклов укажем количество траекторий до крайних клеток. Очевидно, что  в условиях данной задачи оно будет равно 1. Для остальных клеток очевидно существует больше траекторий. Действительно до каждой из них можно добраться из трех соседних клеток: сверху, слева или по диагонали. Поэтому количество траекторий до клетки в i-ой строке и в j-ом столбце равно сумме количеств траекторий до каждой из тех трех соседних клеток. Пробежавшись по всем оставшимся клеткам в двойном цикле, заполним список K необходимыми значениями. В конце можно вывести количество траекторий до любой клетки, например, для клетки в нижнем правом углу.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		m = int(input())\\
		r = int(input())\\
		K = [[0]*m for i in range(n)]\\
		for i in range(n):\\
		\> K[i][0] = 1\\
		for j in range(m):\\
		\> K[0][j] = 1\\
		for i in range(1, n):\\
		\> for j in range(1, m):\\
		\> \> K[i][j] = K[i - 1][j - 1] + K[i - 1][j] + K[i][j - 1]\\
		print(K[n - 1][m - 1])
	\end{tabbing}
}

% 13:30

% 15:00
\subsection*{Наибольшая общая подпоследовательность}

% 16:15 рисунок 2 последовательности
Допустим имеются два числовых списка A и B одинаковой длины. Требуется найти и вывести $F_{ij}$ -- длину наибольшей общей подпоследовательности срезов А[:i+1] и B[:j+1]. Когда эта величина уже посчитана для индексов i-1 и j-1, остается сравнить $A_i$ и $B_j$. Если они равны, то очевидно общая подпоследовательность станет больше на единицу. Иначе будет выбрана наибольшая из $F[i - 1][j]$ и $F[i][j - 1]$.
% 24:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		n = len(A)\\
		m = len(B)\\
		F = [[0]*(m + 1) for i in range(n + 1)]\\
		for i in range(1, n + 1):\\
		\> for j in range(1, m + 1):\\
		\> \> if A[i - 1] == B[j - 1]: \> \> \# i символ А и j символ B\\
		\> \> \> F[i][j] = F[i - 1][j - 1] + 1\\
		\> \> else:\\
		\> \> \> F[i][j] = max(F[i - 1][j], F[i][j - 1])\\
		print(F[n][m])
	\end{tabbing}
}

% СНОСКА: Ссылка на дополнительный материал 

\subsection*{Наибольшая возрастающая подпоследовательность}

% 32:00
Допустим, что существует список А, и необходимо узнать $F_i$ -- длину наибольшей возрастающей подпоследовательности до i-ого элемента включительно. Поэтому $F[0] = 0$. Будем последовательно заполнять список F. При этом если для элемента i списка А найдется меньший его элемент j среди элементов с номерами, меньшими i, и при этом $F[j] > F[i]$, то нужно обновить значение $F[i]$. После этого нужно будет включить элемент $А[i]$ в эту подпоследовательность, а значит, увеличить $F[i]$ на единицу.
% 35:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		F = [0]*len(A)\\
		for i in range(len(A)):\\
		\> for j in range(i):\\
		\> \> if A[j] < A[i] $\backslash$\\
		\> \> \> and F[j] > F[i]:\\
		\> \> \> F[i] = F[j]\\
		\> F[i] += 1\\
		print(max(F))
	\end{tabbing}
}

\end{document}