\chapter{}
\section*{Рекурсия}

Когда при выполнении функции вызывается еще одна функция, происходит запоминание места, откуда совершается переход. После завершения работы этой <<внутренней>>  функции осуществляется воврат к этому месту. Поэтому нет никаких проблем для функции вызвать саму себя. Такой подход называется \emph{рекурсией}.

При этом объекты, на которые ссылаются локальные переменные <<вызывающей>> функции~$f$ не совпадают с объектами, на которые ссылаются локальные переменные <<вызванной>> функции~$f$. Тем самым, при вызове еще одной функции~$f$ происходит создание нового \emph{пространства имен}, и благодаря этому сборщик мусора не удаляет объекты, созданные при предыдущих вызовах функции~$f$.

Пример рекурсивного решения находит свое отражение в сказке о репе. У героя этой сказки деда возникла задача вытянуть репу из земли. Однако его усилий оказалось недостаточно, и он позвал на подмогу бабку. В двоем они также не смогли вытащить репу, и поэтому бабка позвала внучку. Аналогично внучка позвала собачку, собачка -- кошку, кошка -- мышку. Только после этого их совместных усилий хватило для того, чтобы вытащить репу. Данная сказка иллюстрирует один важный момент: чтобы рекурсия не была бесконечной необходимо, чтобы существовал \emph{крайний случай} (в данном случае помощь мыши). При этом по мере спуска вглубь рекурсии задача упрощается (недостаток сил для того, чтобы вытащить репу, уменьшается). 
Данный уровень погружения называется \emph{глубиной рекурсии}.  

\subsubsection*{Создание матрешки}
% 09:00
Хорошей иллюстрацией рекурсии может быть функция имитирующая создание матрешки \texttt{make\_ matroska}. В качестве аргументов в нее  передаются размер матрешки \texttt{size} и количество матрешек \texttt{number}, которое требуется создать. 
Сначала создается (печатается) нижняя половина матрешки. Затем инициируется создание вложенной матрешки. Т.е. осуществляется рекурсивный вызов. Для того чтобы рекурсия не была бесконечной, необходимо в начале выполнения тела функции проверить, нужно ли еще создавать матрешки (\texttt{if number > 1}). Когда это условие не выполнится, выведется сообщение о создании наименьшей в данном случае матрешки. 
После этого будет осуществляться возврат к месту предыдущего вызова и завершаться выполнение тела функции -- создаваться (печататься) верхняя половина матрешки. 
% 18:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def make\_matroska(size, number):\\
		\> if number > 1:\\
		\> \> print('низ размера', size)\\
		\> \> make\_matroska(size - 1, number - 1)\\
		\> \> print('верх размера', size)\\
		\> else:\\
		\> \> print('матрешечка размера', size)\\
	\end{tabbing}
}
При этом внутри тела функции можно выделить два участка: до рекурсивного вызова и после. Первая часть называется \emph{прямым ходом рекурсии}, вторая -- \emph{обратным}. 

\subsection*{Поиск НОД. Алгоритм Евклида}

% 21:00
Рекурсия хорошо применяется при реализации алгоритма Евклида для поиска наибольшего общего делителя. Суть его заключается в том, что если $a$ и $b$ делятся на некоторое число, то и остаток от деления $a$ на $b$ также делится на это число. Благодаря этому можно переходить к исследованию делимости меньших чисел и рекурсивно применять к ним данный алгоритм, пока аналогичный остаток не станет равным нулю. 
% 24:50
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def my\_gcd(a, b):\\
		\> if b == 0:\\
		\> \> return a\\
		\> else:\\
		\> \> return my\_gcd(b, a\%b)\\
	\end{tabbing}
}
\subsection*{Факториал}

% 26:30
Примером неуместного использования рекурсии является реализация алгоритма нахождения факториала натурального числа, несмотря на то, что код выглядит очень лаконичным (особенно с использованием тернарного оператора). 
% 27:40
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def factor(n):\\
		\> return 1 if n == 0 else factor(n - 1)*n\\
	\end{tabbing}
}
Тем самым размер используемой памяти растет пропорционально количеству вызовов $n$. При больших $n$ это может стать существенной проблемой.

\subsection*{Числа Фибоначчи}

% 00:00
Другим <<плохим>> примером может служить рекурсивная функция вычисления числа Фибоначчи. 
% 01:50
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def fib(n):\\
		\> if n < 2:\\
		\> \> return n\\
		\> else:\\
		\> \> return fib(n - 1) + fib(n - 2)
	\end{tabbing}
}
Несложно заметить, что данная функция вызывается избыточное количество раз. Действительно, \texttt{fib(n - 2)} будет определенно при еще вычислении \texttt{fib(n - 1)}. С ростом количества вызовов $n$ количество операций будет увеличиваться пропорционально $2^n$. 

\subsection*{Быстрое возведение в степень}

% 07:00
Операция возведения в степень может быть записана следующим образом.

\begin{tabular}{rl}
	$a^n = $ &  $\left\{ 
	\begin{tabular}{l}
	$1,~\text{при}~n = 0$\\ 
	$a\cdot a^{n - 1},~\text{при}~n \neq 0~\text{и}~n~ \text{нечетное}$\\
	$(a^2)^{n/2},~\text{при}~n \neq 0~\text{и}~n~\text{четное}$\\ 
	\end{tabular} \right. $ \\
\end{tabular} 

Последняя строчка дает возможность сократить количество этапов вдвое при рекурсивном вызове, если $n$ -- четное число. В случае, если $n$ степень двух, количество операций пропорционально $\log_2{n}$. 
% 11:50
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def fast\_power(a, n):\\
		\> if n == 0:\\
		\> \> return 1\\
		\> elif n\%2 == 1:\\
		\> \> return a*fast\_power(a, n - 1)\\
		\> else: \> \>  \# n\%2 == 0\\
		\> \> return fast\_power(a*a, n//2)\\
	\end{tabbing}
}
\subsection*{Ханойские башни}

% 13:00
В качестве примера удачного применения рекурсии удобно рассмотреть задачу о Ханойских башнях. Ее суть заключается в том, что необходимо переложить пирамидку, составленную из блинов разной величины, на другой стержень. При этом за один ход можно перекладывать только один блин, причем так, что бы больший блин не лежал на меньшем, т.е. на каждом стержне находились <<правильные>> пирамидки.

В приведенном ниже решении пирамидку из $n$ блинов перекладывают с $i$ на $j$ стержень. Крайним случаем является пирамидка из одного блина -- тогда решение тривиально. Он совпадает со случаем, когда остался только один не переложенный блин. Если допустить, что существует решение этой задачи для пирамидки из $n - 1$ звеньев, то легко найти решение и для необходимой пирамидки. Действительно, нужно переставить пирамидку из $n - 1$ звеньев на дополнительный свободный стержень, оставшийся самый большой блин переложить на нужный стержень и затем переставить остальные звенья поверх него. 
При этом задача перекладывания меньшей пирамидки аналогична исходной, поэтому удобно для данного действия вызвать ту же функцию, изменив, конечно, параметры. В приведенном ниже примере кода <<перекладывание>> заключается в распечатывании соответствующей строки.
% 21:50
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def hanoi(n, i=1, j=2):\\
		\> if n == 1:\\
		\> \> print('переставить 1', 'блин с', i, 'на', j, 'стержень')\\
		\> else:\\
		\> \> hanoi(n - 1, i, 6 - i - j)\\
		\> \> print('переставить', n, 'блин', n - 1, i, 'на', j, 'стержень')\\
		\> \> hanoi(n - 1, 6 - i - j, j)\\
	\end{tabbing}
}
\subsection*{Генерация комбинаторных объектов}

% 23:30
\subsubsection*{Генерация двоичных чисел}

Для генерации двоичных чисел удобно заполнять строчку нулями и единицами с помощью рекурсивного вызова и выводить двоичное число в крайнем для рекурсии случае. В приведенной ниже функции \texttt{bin\_gen} на вход подаются количество цифр в числе \texttt{n} и строка \texttt{prefix}, в которую будет записываться часть генерируемого числа  и которая будет передаваться каждой новой функции. Она необходима, так как число <<собирается>>, удлиняясь при каждом новом вызове. Для обработки крайнего случая отдельно рассмотрена ситуация, когда n равно нулю. Если же это не так, то, удостоверившись, что n неотрицательно, осуществляется <<сборка>> числа по двум направлениям: в одном случае цифра с номером n будет равна 1, во втором -- 0. Очевидно, что рекурсия достигнет крайнего случая, и программа напечатает ровно $2^n$ чисел. 
% 28:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def bin\_gen(n, prefix = ''):\\
		\> if n == 0:\\
		\> \> print(prefix)\\
		\> else:\\
		\> \> assert(n > 0)\\
		\> \> bin\_gen(n - 1, prefix + '0')\\
		\> \> bin\_gen(n - 1, prefix + '1')\\
	\end{tabbing}
}
\subsubsection*{Генерация перестановок в списке}

% 30:00
Еще одним примером использования рекурсии может служить генерация всех возможных перестановок в списке. Для простоты пусть элементы списка -- это целые числа от 1 до n + 1. Список с перестановкой будет <<собираться>> по аналогии с предыдущим примером. Когда длина списка станет равной n (крайний случай), элементы списка будут выведены на экран с помощью \texttt{print(*A)}. Для того чтобы сгенерировать все перестановки рекурсивный вызов осуществляется в цикле, в котором пробегаются необходимые элементы. Чтобы последние не повторялись используется проверка на то, входит ли текущий элемент в частично созданный список.
% 34:40
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def perestanov\_gen(n, A=[])\\
		\> if len(A) == n:\\
		\> \> print(*A)\\
		\> else:\\
		\> \> for x in range(1, n + 1):\\
		\> \> \> if x not in A:\\
		\> \> \> \> perestanov\_gen(n, A + [x])\\
	\end{tabbing}
}
Стоит отметить, что количество вызовов такой функции будет крайне велико и важно не допустить достижения максимальной глубины рекурсии, разрешенной в Python. 