\chapter{}
\subsection*{Очередь (queue)}

Очередь -- это структура данных, в которую можно добавлять элемент в ее конец и извлекать элемент из ее начала. Одним из простых видов очереди является FIFO (First Input -- First Out). В такой очереди первый вошедший элемент является первым претендентом на выход. 

Очередь требуется, когда наблюдается недостаток ресурсов. Например, если некоторая программа не может обрабатывать больше двадцати запросов в секунду, то на двадцать первый запрос очередь переполнится, т.е. запросы перестанут попадать в нее. 

В стандартной библиотеке Python есть модуль queue, который позволяет создавать очередь и работать с нею. 

%19:00
Создается очередь, как и любой объект класса, с помощью вызова конструктора Queue. Ему можно передать количество элементов, которые можно хранить в памяти одновременно. Можно узнать пуста ли очередь с помощью метода empty и проверить на полноту, используя метод full (они возвращают правду или ложь). Чтобы положить элемент в очередь нужно воспользоваться методом put, а для того чтобы извлечь -- get.

\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{2cm}\=\kill
		import queue\\
		q = Queue(10) \> \> \# очередь из 10 элементов\\
		q.empty()\\
		q.full\\
		q.put(item)\\
		q.get()
	\end{tabbing}
}

Попробуем реализовать класс Queue, используя двусвязный список, с максимальным количеством звеньев, равным количеству элементов в очереди. Реализуем конструктор. По умолчанию очередь создается пустой, и начало (\_begin) и конец (\_end) указывают на None; максимальное количество элементов (N\_max) можно задать в конструкторе, однако по умолчанию оно равно нулю; еще один атрибут (N) -- это текущее количество элементов в очереди.

Методы empty и full реализуются очевидным образом.
Во время выполнения операции добавления нового элемента в случае, когда очередь уже полна, будет вызвана ошибка. Более того, если очередь пуста, то операция будет работать иначе, чем когда в очереди уже есть элементы. Так как список двусвязный, то необходимо связать не только новый первый элемент со старым, но и наоборот.

Если очередь пуста, то метод извлечения элемента get вызовет ошибку. Если она не пуста, то последний элемент можно извлечь. При этом необходимо сначало сохранить ссылку на этот элемент, прежде чем у предпоследнего элемента в качестве ссылки на последний указать None. Важно обратить внимание, что сборщик мусора удалит элемент, только когда на него не останется ни одной ссылки. В случае когда в очереди был всего один элемент, необходимо также удалить ссылку на него как на начало очереди.


\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		class Queue:\\
		\> def \_\_init\_\_(self, N=0):\\
		\> \> self.\_begin = None\\
		\> \> self.\_end = None\\
		\> \> self.\_N\_max = N\\
		\> \> self.\_N = N\\
		\\
		\> def empty(self):\\
		\> \> return self.\_N == 0\\
		\\
		\> def full (self):\\
		\> \> return self.\_N == self.\_N\_max if self.\_N\_max != 0 else False\\
		\\
		\> def put(self, item):\\
		\> \> if self.full():\\
		\> \> \> raise Error() \> \# вызов ошибки при переполнении\\
		\> \> if self.empty():\\
		\> \> \> self.\_begin = self.\_end = [None, item, None]\\
		\> \> \> \# ставим None, так как предыдущего и следующего звена нет\\
		\> \> else:\\
		\> \> \> new\_node = (None, item, self.\_begin)\\
		\> \> \> self.\_begin = new\_node\\
		\> \> \> \# теперь новый первый элемент связан со старым первым элементом\\
		\> \> \> self.\_begin[2][0] = self.\_begin\\
		\> \> \> \# теперь старый первый элемент связан с новым первым элементом\\
		\> \> self.\_N += 1 \> \> \#  количество элементов увеличилось на единицу\\
		\\
		\> def get(self):\\
		\> \> if self.empty():\\
		\> \> \> raise Error()\\
		\> \> item = self.\_end[1]\\
		\> \> \> \# теперь последний элемент сохранен\\
		\> \> self.\_end = self.\_end[0]\\
		\> \> \> \# теперь последним является ранее предпоследний элемент\\
		\> \> if self.\_end == None: \> \> \# т.е. был всего один элемент\\ 
		\> \> \> self.\_begin = None\\
		\> \> else:\\
		\> \> \> self.\_end[2] = None \> \# так как он теперь последний\\
		\> \> \> \# теперь ссылка на последний элемент будет утеряна во всех случаях\\
		\> \> self.\_N -= 1
	\end{tabbing}
}

\subsection*{Куча (heap)}

Куча или пирамида представляет собой двоичное дерево, в котором самый большой элемент находится на самом верху. Каждый элемент пирамиды пронумерован в порядке сверху вниз и слева направо. На самой верхней ступени один элемент, на второй -- два, на третьей -- четыре и т.д. Нулевой элемент является родительским для первого и второго, первый -- для третьего и четвертого, второй -- для пятого и шестого. В общем случае для элемента с индексом i родительским является элемент  индексом j = (i - 1) // 2. Тем самым пирамиду можно хранить в виде обычного списка: место элемента в пирамиде будет определяться его индексом. В пирамиде поддерживается следующая упорядоченность: каждый дочерний элемент не больше родительского. Если количество элементов равно нулю или одному, то, очевидно, ничего делать не требуется, однако если их больше, то при добавлении нового элемента (обычно в конец списка) нужно определить место последнего в родительской цепочке, сравнивая их и, если потребуется, меняя местами. 

В качестве примера реализуем класс Heap только лишь с конструктором и методом вставки нового элемента put.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		class Heap:\\
		\> def \_\_init\_\_(self):\\
		\> \> self.\_m = []\\
		\> def put(self, item):\\
		\> \> self.\_m.append(item)\\
		\> \> i = len(self.\_m) - 1\\
		\> \> j = (i - 1) // 2\\
		\> \> while i != 0 and self.\_m[i] > self.\_m[j]:\\
		\> \> \> self.\_m[i], self.\_m[j] = self.\_m[j], self.\_m[i]\\
		\> \> \> i = j\\
		\> \> \> j = (i - 1) // 2
	\end{tabbing}
}

\subsection*{Очередь LIFO или стек(stack)}

Стек представляет собой очередь, в которой последний вошедший является первым претендентом на выход (Last In -- First Out). Для стека характерны метод пополнения стека push и метод извлечения последним вошедшего элемента pop, чья реализация является очевидной. 
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{4cm}\=\kill
		class Stack:\\
		\> def \_\_init\_\_(self):\\
		\> \> self.\_m = []\\
		\> def push(self, item):\\
		\> \> self.\_m.append(item)\\
		\> def pop(self):\\
		\> \> top = self.\_m[-1]\\
		\> \> self.\_m.pop()\\
		\> \> return top
	\end{tabbing}
}
Стек применяется для правильного взаимоотношения вызываемых функций (стек вызовов). 

\subsection*{Исключения}
В процессе работы программы часто возникают исключительные случаи. Например, это может быть деление на ноль или некорректный ввод (вместо цифры случайно нажимается клавиша с буквой). 
Для обработки исключений существует блок try ... except. 
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def f():\\
		\> try:\\
		\> \> \# команды нормального выполнения\\
		\> except:\\
		\> \> \# команды исключения
	\end{tabbing}
}

После except можно указать, какую конкретную ошибку следует обрабатывать (например, TypeError или ZeroDivisionError). Можно также указать несколько обработчиков для разных типов ошибок (это напоминает блок if ... elif ... elif ... else). 

Если несколько функций вызывают одна другую, то каждая из них может обрабатывать какие-нибудь из возможных ошибок. При возникновении ошибки, она будет <<искать>> свой обработчик, двигаясь по стеку вызовов от самой последней вызванной функции до первой, пока не натолкнется на него. Если же этого не произойдет, то будет осуществлен выход из всей программы с сообщением о конкретной ошибке. 