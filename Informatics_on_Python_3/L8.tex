\chapter{}
\subsection*{Сортировка выбором}	

Рассмотренная ранее сортировка вставками может быть удобна, когда имеется необходимость сортировать некоторый массив элементов по мере его наполнения. В сортировке выбором на каждом этапе ищется тот элемент, который должен стоять н текущей позиции в отсортированном списке. Т.е. сперва находиться наименьший элемент и ставится в начало списка. Затем будет осуществляться поиск больших чисел; при этом они займут сразу правильные места и до конца сортировки переставляться не будут, в отличие от сортировки выбором. 

Реализация данного алгоритма выглядит следующим образом. В цикле пробегаются все позиции кроме последней (когда n - 1 элементов будут отсортированы, очевидно, оставшийся элемент будет находиться на нужном месте). Для каждой позиции ищется наименьший элемент из всех оставшихся правее элементов, включая последний. Если среди них найдется число, меньшее элемента на текущей позиции, то они меняются местами. Таким образом к моменту выхода из внешнего цикла список будет отсортирован. Сложность данного алгоритма составляет $O(n^2)$. 
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		for pos in range(N - 1):\\
		\> for i in range(pos + 1, N):\\
		\> \> if A[i] < A[pos]:\\
		\> \> \> tmp = A[i]\\
		\> \> \> A[i] = A[pos]\\
		\> \> \> A[pos] = tmp
	\end{tabbing}
}	

\subsection*{Сортировка методом пузырька}

Существуют структуры данных, в которых доступ до i-ого элемента происходит за не менее i шагов. В таком случае неудобно сравнивать далеко стоящие элементы. Можно осуществить проход списка, сравнивая соседние элементы и упорядочивая их в пределах каждой пары. По окончании прохода максимальный элемент окажется в крайней правой позиции, т.е. будет отсортирован. Применяя аналогичный алгоритм к оставшимся элементам, осуществляется сортировка всего списка. 

Для реализации данного алгоритма заведем переменную prohod, показывающую, что на каждой итерации нужно пробежать N - prohod элементов, начиная с крайнего левого. Так как на первом проходе осуществляется N - 1 сравнений, то удобно организовать проходы с помощью цикла от 1 до N не включая последнего. Если какая-то сравниваемая пара неупорядоченна, то элементы в ней меняются местами. Как и в предыдущем примере сложность данного алгоритма составляет $O(n^2)$.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		for prohod in range(1, N):\\
		\> for i in range(N - prohod):\\
		\> \> if A[i] > A[i + 1]:\\
		\> \> \> tmp = A[i]\\
		\> \> \> A[i] = A[i + 1]\\
		\> \> \> A[i + 1] = tmp
	\end{tabbing}
}

\subsection*{Сортировка дурака}	

В плохих случаях имеет асимптотику $O(N^3)$.
% 20:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		i = 0\\
		while i < N - 1:\\
		\> if A[i] < A[i + 1]:\\
		\> \> i += 1\\
		\> else:\\
		\> \> tmp = A[i]\\
		\> \> A[i] = A[i - 1]\\
		\> \> A[i + 1] = tmp\\
		\> \> i = 0
	\end{tabbing}
}

\subsection*{Сортировка подсчетом}

Допустим, что необходимо отсортировать следующие элементы.
\[1 ~2 ~3 ~2 ~2 ~0 ~7 ~6 ~5 ~2 ~3 ~8 ~8 ~1 ~1 ~2 ~3 ~0 ~9 ~8 ~8 ~7 ~6 ~3 ~2\]

С помощью метода пузырька или другими описанными ранее методами на решение данной задачи уйдет около $25^2 \gtrsim 600$ шагов. Однако можно заметить, что следующий массив содержит не больше 10 различных элементов, каждый из которых представляет небольшое неотрицательное число. Используя дополнительный массив счетчиков frequency можно понизить сложность сортировки до $O(N)$. Считывая в цикле элементы от 0 до 9, будем обновлять в массиве frequency частоту их вхождений. После этого останется только вывести эти элементы в порядке неубывания столько раз, сколько каждый элемент входил в исходный список. 
% 33:00
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		frequency = [0]*10\\
		digit = int(input())\\
		while 0 <= digit <= 9:\\
		\> frequency[digit] += 1\\
		\> digit = int(input())\\
		for digit in range(10):\\
		\> print(*[digit]*frequency[digit], end=' ')
	\end{tabbing}
}

Однако данный алгоритм будет работать очень долго, если среди возможных чисел будут очень большие. Например, пусть требуется упорядочить всего четыре числа.
\[7 ~1 ~512 ~1875514852\]

Используя сортировку подсчетом, потребуется обнулить более чем миллиард элементов массива frequency, на что уйдет приблизительно столько же операций. К тому же потребуется внушительный размер дополнительно используемой памяти.

\subsection*{Поразрядная сортировка}

Данная сортировка применима только для целых чисел или коротких строк и имеет линейную асимптотику $O(N\cdot M)$, где M -- характерный размер сортируемых чисел. Для больших чисел асимптотика ухудшается. 

Допустим нужно упорядочить следующие числа.
\[ 753 ~58 ~236 ~200 ~18 ~211 ~214 ~758 ~812 ~7\] 

Начнем сортировать числа по их младшим разрядам, т.е. по их последним цифрам. Тогда получим список, в котором числа, отличаются только последней цифрой, будут упорядоченны друг относительно друга (например, 211 и 214, 753 и 758).
\[200 ~211 ~812 ~753 ~214 ~236 ~7 ~58 ~18 ~758\]

Аналогично сортируя числа по всем остальным разрядам, получим упорядоченный список. 

Для реализации данного алгоритма определим максимальную длину числа, входящего в список. Пробегаясь по всем разрядам до максимального (в десятичной системе счисления), произведем сортировку, аналогично тому, как показано выше.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		A = [int(x) for x in input().split()]\\
		max\_num\_len = max([len(str(x)) for x in A])\\
		for radix in range(0, max\_num\_len):\\
		\> B = [[] for i in range(10)]\\
		\> for x in A:\\
		\> \> digit = (x // (10 ** radix)) \% 10\\
		\> \> B[digit].append(x)\\
		\> \> A[:] = []\\% что делает эта строка?
		\> for digit in range(10):\\
		\> A += B[digit]
	\end{tabbing}
}

\subsubsection*{Проверка типа входных данных}

\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def sort\_number(A):\\
		\> assert(type(A[0]) == 'class<int>')
	\end{tabbing}
}
