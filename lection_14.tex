% !TeX spellcheck = russian_english
% !TeX encoding = UTF-8
\documentclass[a4paper, fleqn]{article}

\usepackage{indentfirst} % Красная строка
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[russian]{babel} % руссификация
\usepackage{amssymb} % дополнительные символы
\usepackage{textcomp} % дополнительные текстовые символы
\usepackage{amsmath} % матрицы
\usepackage{listings}
% листинги
\lstset{language=Python, tabsize=4, language=Python}


\textwidth = 16 cm
\oddsidemargin= 0 cm
\evensidemargin= 1 cm


% \abovedisplayskip = 0 pt %.2\abovedisplayskip
% \belowdisplayskip = .2\belowdisplayskip
% \abovedisplayshortskip=.2\abovedisplayshortskip
% \belowdisplayshortskip=.2\belowdisplayshortskip
% \topsep= 0 pt

% \setlength{\mathindent}{1.2 cm}
% \setlength{\topsep}{0 pt}
% \setlength{\abovedisplayskip}{0 pt}

% \clubpenalty = 5000 % запрет висячих строк
% \widowpenalty = 5000
\binoppenalty=10000
\relpenalty=10000

% собственные команды и окружения

\newenvironment{example}[1][]{\medskip \noindent \textbf{Пример. #1}\par \nopagebreak}{\medskip \par} % окружение-"пример"


\title{Лекция \textnumero\,13}
% {\huge \vspace{3 cm}}}

\author{Т.\,Ф. Хирьянов}

\date{}

\begin{document}
	\maketitle

\subsection*{Хэширование. Хэш-функция}

Представим себе экзамен. У каждого студента есть зачетная книжка. Семинарист подписал каждому конкретному студенту конкретный билет. Студенты положили свои зачетки на стол в произвольном порядке. Получилось два списка: фамилий и номеров билетов. Ставится задача вложить в каждую зачетку соответствующий билет и оценить сложность решения для различных алгоритмов (количество студентов равно N). 

Первый способ состоит в том, что для каждой следующей зачетки просматриваются все оставшиеся фамилии. Это полный перебор, и его сложность $O(N^2)$. 

Второй способ состоит в том, что можно отсортировать оба списка по ключам. Тогда асимптотика соответствует скорости сортировки (например, может быть достигнута скорость $O(N\cdot\ln_2{N})$).

Однако наиболее эффективным является третий способ. Записать все фамилии и соответствующие им билеты в словарь (dict), где ключем является фамилия, а значением -- номер билета. Сложность создания словаря составит $O(N)$, а сложность поиска в нем -- $O(1)$ (т.е. за конечное количество операций не зависящих от количества элементов).\\ 

Рассмотрим другую задачу. Каким образом лучше всего организовать телефонную книгу, чтобы быстрее всего по номеру определить абонента?
 
Один из способов -- отсортировать кортежи (номер, фамилия) по номерам. Тогда задача решится бинарным поиском и сложность составит $O(\ln_2{N})$. Это хороший способ, однако не идеальный.

Пусть например есть записная книжка из 100 страниц. Тогда каждого нового абонента можно записывать на страницу с номером, равным остатку от деления номера абонента на 100 (т.е. запись <<12345 -- Вася>> попадет на 45 страницу).
Такой подход называется \emph{хэшированием}: ключу (номеру) сопоставляется хэш-функция (остаток от деления). 
\subsection*{Коллизии}

Так как у пятизначных номеров (в разобраном выше примере) мощность ключей - $10^5$, а мощность множества индексов (количество страниц) $10^2$, то, очевидно, возможна \emph{коллизия} -- на одну страницу попадут несколько номеров.
Если одной хэш-функции соответствует очень много ключей то имеет место массовая коллизия. Поэтому для для хэш-функций существует следующее требование: для близко лежащих значений они должны давать существенно различные результаты. Еще одним требованием является скорость работы хэш-функции. Если она низкая, то хэширование теряет свое преимущество. 

Есть два пути разрешения коллизий: открытая и закрытая хэш-таблицы. В первом случае разрешается записывать несколько номеров на странице -- получается словарь списков. Во втором случае это запрещается и <<лишние>> номера записываются в следующую ячейку. 

Если нарисовать асимптотику скорости поиска в открытой хэш-таблице от количества хранимых данных, то вначале она будет константой, а по мере приближения к максимальному количеству ячеек будут возникать коллизии и время поиска будет увеличиваться; когда это значение будет пройдено асимптотика станет линейной.  

Для закрытой хэш-таблицы зависимость практически аналогична, однако по достижении максимума больше в нее будет нельзя ничего добавить.

\subsection*{Открытая хэш-таблица}

Описанную выше открытую хэш-таблицу можно реализовать следующим образом.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{6cm}\=\kill
		Class MyDict:\\
		\> N\_max = 100 \> \> \> \# максимальный размер таблицы\\
		\\
		\> def add(self, key, value):\\
		\> \> i = hash(key) \% N\_max \\
		\> \> j = 0\\
		\> \> while j < len(self.\_M[i]): \> \> \> \# пока i-й список не закончился\\ 
		\> \> \> if self.\_M[i][j][0] == key: \> \> \# ключ j-ого кортежа в i-ом списке.\\
		\> \> \> \> self.\_M[i][j] = (key, value)  \> \# перезаписываем значение для ключа\\
		\> \> \> \> break\\
		\> \> else: \> \> \> \# вышли из цикла, но break не было\\
		\> \> \> self.\_M[i].append((key, value)) \> \> \# можно записать пару ключ-значение\\
		\\
		\> def \_\_init\_\_(self, lst=[]):\\
		\> \> self.\_M = [ [] for I in range(N\_max)] \> \> \> \# список пустых списков\\
		\> \> for i, value in lst: \hspace{1cm} \# бежит по парам ключ-значение поданного списка\\
		\> \> \> self.add(key, value)
	\end{tabbing}
}
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3.5cm}\=\kill
		\> def get(self, key):\\
		\> \> i = hash(key) \% N\_max\\
		\> \> for k, v in self.\_M[i]: \> \> \> \# поиск в i-ом списке пар\\
		\> \> \> if k == key:\\
		\> \> \> \> return v\\
		\> \> \> return None \>\> \# хотя лучше вызвать исключение
	\end{tabbing}
}
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{5cm}\=\kill
		\> def del(self, key):\\
		\> \> i = hash(key) \% N\_max \\
		\> \> j = 0\\
		\> \> while j < len(self.\_M[i]): \>\>\> \# пока i-й список не закончился\\ 
		\> \> \> if self.\_M[i][j][0] == key: \>\> \# ключ j-ого кортежа в i-ом списке.\\
		\> \> \> \> self.\_M[i].pop(j) \hspace{1cm} \> \# удаляем пару ключ-значение\\
		\> \> \> \> return\\
		\> \> raise KeyError() \hspace{1cm} \> \> \> \# если удалять нечего		
	\end{tabbing}
}

\end{document}
