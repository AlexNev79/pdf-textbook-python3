% !TeX spellcheck = russian_english
% !TeX encoding = UTF-8
\documentclass[a4paper, fleqn]{article}

\usepackage{indentfirst} % Красная строка
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[russian]{babel} % руссификация
\usepackage{amssymb} % дополнительные символы
\usepackage{textcomp} % дополнительные текстовые символы
\usepackage{amsmath} % матрицы
%\usepackage{pdfpages}
%\usepackage{pgfplots}
%\usepackage{pgfplotstable}
\usepackage{listings}
% листинги
\lstset{language=Python, tabsize=4, language=Python}


\textwidth = 16 cm
\oddsidemargin= 0 cm
\evensidemargin= 1 cm


% \abovedisplayskip = 0 pt %.2\abovedisplayskip
% \belowdisplayskip = .2\belowdisplayskip
% \abovedisplayshortskip=.2\abovedisplayshortskip
% \belowdisplayshortskip=.2\belowdisplayshortskip
% \topsep= 0 pt

% \setlength{\mathindent}{1.2 cm}
% \setlength{\topsep}{0 pt}
% \setlength{\abovedisplayskip}{0 pt}

% \clubpenalty = 5000 % запрет висячих строк
% \widowpenalty = 5000
\binoppenalty=10000
\relpenalty=10000

% собственные команды и окружения

\newenvironment{example}[1][]{\medskip \noindent \textbf{Пример. #1}\par \nopagebreak}{\medskip \par} % окружение-"пример"


\title{Лекция \textnumero\,11}
% {\huge \vspace{3 cm}}}

\author{Т.\,Ф. Хирьянов}

\date{}

\begin{document}
	\maketitle

\subsection*{Быстрая сортировка Хоара}

% 3:30
Допустим, что необходимо упорядочить солдат в строю по их росту. Решение данной задачи с помощью быстрой сортировки Хоара начинается с того, что выбирается произвольный солдат и весь строй разделяется на три группы по отношению к нему: тех, кто ниже ростом, тех, кто одинакового с ним роста и тех, кто выше. Получается, что люди во второй группе, уже отсортированы внутри нее. К тому же первая вторая и третья группы  упорядоченны между собой. Однако внутри первой и третьей группы люди могут быть неупорядоченны. Осталось рекурсивно применить к этим группам тот же самый алгоритм. 

Из сказанного следует, что данная рекурсивная сортировка относится к алгоритмам типа <<разделяй и влавствуй>>, а также то, что массив данных сортируется на прямом ходу рекурсии. Подробный анализ показывает, что приведенный метод в худшем случае имеет асимптотику $O(N^2)$, однако вероятностно, в некотором <<среднем случае>> $O(N\cdot\log_2{N})$. 

Рассмотрим для наглядности реализацию, в которой для этих трех групп создаются новые списки (хотя можно обойтись и без этого).  
Сначала обрабатывается крайний случай рекурсии, который заключается в том, что список из не более одного элемента уже отсортирован. 
Затем с помощью библиотечной функции \texttt{choice} выбираем произвольный элемент, который будет выполнять роль барьера. Сравнивая с ним остальные элементы списка A, создаем с помощью генераторов три новых списка \texttt{left, middle, right}. К первому и третьему рекурсивно применяем тот же алгоритм. В конце работы программы возвращаем конкатинированный список. 


\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		from random import choice\\
		def hoar\_sort(A):\\
		\> if len(A) <= 1:\\
		\> \> return A\\
		\> barrier = choice(A)\\
		\> left = [x for x in A if x < barrier]\\
		\> middle = [x for x in A x == barrier]\\
		\> right = [x for x in A x > barrier]\\
		\> left = hoar\_sort(left)\\
		\> right = hoar\_sort(right)\\
		\> return left + middle + right
	\end{tabbing}
}

Стоит отметить, что важным преимуществом быстрой сортировки является ее универсальность, т.е. возможность ее применения к любым элементам, которые можно сравнивать между собой, даже если к ним не применимы арифметические операции, например, к строкам.

\subsection*{Быстрая сортировка слиянием}

% 27:30
Представим, что студент распечатал внушительный отчет о проделанной лабораторной работе, однако из-за того, что форточка в комнате была открыта, ветер раскидал листки по комнате и перепутал их. Предположим, что двое соседей студента решили ему помочь и каждый, собрав произвольную стопку листов, упорядочил страницы в ней. Эти две отсортированные стопки они отдали студенту. Теперь задача студента сводится к тому, чтобы произвести <<слияние>> этих двух стопок. Он ставит их так, чтобы страницы с наименьшими номерами были в верху стоп. Таким образом студент все время видит две страницы, выбирает из них ту, у которой номер меньше и откладывает в третью стопу. 

Тем самым обработан крайний случай, когда уже имеется две отсортированных части списка. Последние можно получить рекурсивно. Для этого нужно, чтобы для каждой из них также существовали их отсортированные части. 
Легко заметить, что сортировка происходит на обратном ходу рекурсии. Асимптотика такого алгоритма равна $O(N\cdot\log_2{N})$, однако он потребляет $O(N)$ дополнительной памяти. 

Для реализации данного алгоритма потребуется сперва создать функцию слияния \texttt{merge}, которая по двум отсортированным спискам A и B возвращает их общий упорядоченный список Res. По аналогии с описанным выше методом поэлементно пробегаются оба списка, пока каждый из них не закончится.  
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def merge(A, B):\\
		\> Res = []\\
		\> i = 0\\
		\> j = 0\\
		\> while i < len(A) and j < len(B):\\
		\> \>if A[i] < B[j]:\\
		\> \> \> Res.append(A[i])\\
		\> \> \> i += 1\\
		\> \> else:\\
		\> \> \> Res.append(B[j])\\
		\> \> \> j += 1\\
		\> Res += A[i:] + B[j:] \> \> \> \# один из срезов обязательно пуст\\
		\> return Res
	\end{tabbing}
}

Теперь реализуем функцию \texttt{merge\_sort(A)}. Крайним будет случай, когда список A состоит из не более одного элемента. Тогда можно считать, что список уже отсортирован, однако если в нем больше элементов, то левую <<половину>> сохраняем в список \texttt{left}, а правую в список \texttt{right}. Далее для них выполняем те же самые действия рекурсивно. Стоит обратить внимание, что сортировка осуществляется на обратном ходу рекурсии, когда списки \texttt{left} и \texttt{right} подвергаются слиянию.
\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		def merge\_sort(A):\\
		\> if len(A) <= 1:\\
		\> \> return A\\
		\> left = A[:len(A) // 2]\\
		\> right = A[len(A) // 2:]\\
		\> left = merge\_sort(left)\\
		\> right = merge\_sort(right)\\
		\> return merge(left, right)
	\end{tabbing}
}

\subsection*{Пирамидальная сортировка}

% 52:30

\texttt{
	\begin{tabbing}
		\hspace{8mm}\=\hspace{8mm}\=\hspace{8mm}\=\hspace{3cm}\=\kill
		from heapq import*
		def heap\_sort(A):\\
		\> heapify(A)\\
		\> Res = []\\
		\> while len(A) != 0:\\
		\> \> x = heappop(A)\\
		\> \> Res.append(x)\\
		\> return Res
	\end{tabbing}
}

\subsection*{Устойчивость сортировки}

% 1:08:00



\end{document}