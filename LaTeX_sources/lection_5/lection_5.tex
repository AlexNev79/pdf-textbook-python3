% !TeX spellcheck = russian_english
% !TeX encoding = UTF-8
\documentclass[a4paper, fleqn]{article}

\usepackage{indentfirst} % Красная строка
\usepackage[T2A]{fontenc} % Поддержка русских букв
\usepackage[utf8]{inputenc} % Кодировка utf8
\usepackage[russian]{babel} % руссификация
\usepackage{amssymb} % дополнительные символы
\usepackage{textcomp} % дополнительные текстовые символы
\usepackage{amsmath} % матрицы
%\usepackage{pdfpages}
%\usepackage{pgfplots}
%\usepackage{pgfplotstable}
\usepackage{listings}
% листинги
\lstset{language=Python, tabsize=4, language=Python}


\textwidth = 16 cm
\oddsidemargin= 0 cm
\evensidemargin= 1 cm


% \abovedisplayskip = 0 pt %.2\abovedisplayskip
% \belowdisplayskip = .2\belowdisplayskip
% \abovedisplayshortskip=.2\abovedisplayshortskip
% \belowdisplayshortskip=.2\belowdisplayshortskip
% \topsep= 0 pt

% \setlength{\mathindent}{1.2 cm}
% \setlength{\topsep}{0 pt}
% \setlength{\abovedisplayskip}{0 pt}

% \clubpenalty = 5000 % запрет висячих строк
% \widowpenalty = 5000
\binoppenalty=10000
\relpenalty=10000

% собственные команды и окружения

\newenvironment{example}[1][]{\medskip \noindent \textbf{Пример. #1}\par \nopagebreak}{\medskip \par} % окружение-"пример"


\title{Лекция \textnumero\,5}
% {\huge \vspace{3 cm}}}

\author{Т.\,Ф. Хирьянов}

\date{}

\begin{document}
	\maketitle
	
	\section*{Работа со списками в Python 3}
	
	\subsection*{Кодировки символов}
	
	Американская стандартная система кодирования ASCII позволяла сопоставить распространенным печатным и непечатным символам соответствующие числовые коды. Изначально она включала в себя латинский алфавит. С помощью изменения старшего бита на 1 имелась возможность кодировать национальные символы. Из-за этого возникло очень много  различных национальных кодировок. Более того, такой подход не позволял писать международные письма, использующие одновременно несколько кодировок.
	 
	% 03:12
	Это привело к созданию международного стандарта  Unicode, который предлагал несколько кодировок, среди которых UTF-16, UTF-32. Первая из них позволяла кодировать $65532$ символа, а вторая приблизительно $4\cdot10^9$, причем в них на каждый символ отводилось одинаковое количество памяти. Из-за довольно большого размера таких равномерных кодировок была предложена новая UTF-8, которая являлась неравномерной, т.е. в ней разные символы имеют разную длину. Также это позволяет добавлять все новые и новые символы. Язык Python  ориентирован на стандарт Unicode, поэтому в строках можно использовать любые символы, если знать их код.
	
	\subsection*{Тип str}
	
	% 05:53
	Для разных языков программирования существуют разные подходы к реализации символьного типа. Например, в Pascal это тип \emph{char}, который  является символьным. В языке программирования Си существует тип с таким же названием, который является числовым.  В Python же не существует символьного типа, вместо этого есть тип <<строка>> (\emph{str}). Чтобы обратиться к  конкретному символу в строке необходимо указать его номер в качестве индекса. 
	\begin{lstlisting}
		s = 'Hello'
		s[0] == 'H'
		type(s[0]) == class<str>
	\end{lstlisting}
	Также символ можно понимать как срез строки длиной в один символ. При этом необходимо учитывать, что, например, в Pascal строки изменяемые. В Python это не так -- для того чтобы изменить строку, необходимо породить новый объект и затем сделать привязку к старому идентификатору. 
	
	\subsection*{Функции строк}
	
	% 10:00
	Для работы со строками  одними из самых важных являются функции поиска подстроки в строке find и rfind, которые имеют похожий синтаксис. 
	\begin{lstlisting}
		s = 'Ehehe...'
		s.find('he') # return 1
		s.rfind('he') # return 3
	\end{lstlisting}
	
	При этом функция find возвращает позицию первого символа подстроки, найденной от начала строки. Но функция rfind осуществляет поиск с конца строки и, соответственно, возвращает  позицию последнего элемента подстроки.
	
	Для того чтобы найти количество вхождений подстроки в строку существует функция count. 
	В случае перекрывания подстрок, как в данном примере, 
	\begin{lstlisting}
		s = 'AAAA'
		num_AA = s.count('AA')		# num_AA == 2
	\end{lstlisting} 
	можно считать, что подстрока вошла два или три раза. В Python 3 принято считать что здесь две подстроки. 
	
	\subsection*{Литералы строк}
	
	Строка в Python записывается в одинарных или двойных кавычках. Обе записи равнозначны и существуют для того, чтобы избегать двусмысленных выражений. Впрочем, можно было бы использовать обратный слэш для экранирования кавычек (например, \\'), чтобы они воспринимались как символы внутри строки. 
	
	Если строка слишком длинная, чтобы уместиться на экране, то разумно перенести ее с помощью обратного слэша, который будет экранировать не печатающийся символ переноса каретки. При этом Python будет воспринимать ее как одну целую строку.
	
	Для того чтобы работать с многострочным объектом, его записывают в тройных кавычках (каждая из которых состоит из одной либо двух кавычек). 
	\begin{lstlisting}
		s = 'Ehehe...'
		s = "Ehehe..."
		
		s_with_comma = 'I\'m a student'
		s_with_comma = "I'm a student"
		s_with_comma = 'Company "Parallels"'
		
		long_s = "... \
				..."
		
		many_s = ''' ...
				...
				... '''		
	\end{lstlisting}
	
	Для написания строк бывает удобно пользоваться специальными символами, такими как\\
	<<$\backslash n$>> -- разрыв строки\\
	<<$\backslash t$>> -- табуляция
	
	Для того чтобы хранить в строке путь к некоторому файлу в Windows, необходимо экранировать обратный слэш (т.е. сделать его двойным). Можно также написать перед открывающей кавычкой символ \emph{r}. Тогда все, что находится внутри кавычек будет восприниматься так, как написано.
	\begin{lstlisting}
		path = 'C:\\my\\1.py'
		path = r'C:\my\1.py'
	\end{lstlisting}
	
	\subsection*{Наивный поиск подстроки в строке}
	
	В качестве примера алгоритма можно рассмотреть поиск позиции первого элемента первого вхождения подстроки <<he>> в строку <<Ehehe...>>. 
	
	Для начала определяются их длины. Затем элементы в строке пробегаются до той позиции, при которой подстрока, начинавшаяся бы с нее, еще не вышла бы за пределы строки. 
	В теле цикла проверяется совпадение подстроки с частью строки, начинающейся с текущей позиции. В случае несовпадения происходит выход из вложенного цикла. Для того чтобы выйти из внешнего цикла сразу после нахождения нужной подстроки используется логическая переменная-флаг found. В случае, если такой подстроки нет, программа возвращает $-1$.
	\begin{lstlisting}
		s = 'Ehehe...'
		sub = 'he'
		len_s = len(s)
		len_sub= len(sub)
		
		pos = 0
		while pos + len_sub <= len_s:
			found = True
			i = 0
			while i < len_sub:
				if s[pos + i] != sub[i]:
					found = False
				i += 1
			if found:
				break
			pos += 1
		else:
			pos = -1			
	\end{lstlisting}
	
	
	\subsection*{Списки в Python}
	
	% 33:00
	В Python список (тип list) представляет собой массив ссылок на объекты. Он изменяем: каждую ссылку можно связать с другим объектом. 
	\begin{lstlisting}
		A = [1, 2, 3, 4, 5]		# type(A) == class<list>
		A[0] = 10				# type(A[0]) == int
								# A == [10, 2, 3, 4, 5]
	\end{lstlisting}
	Можно узнать длину списка с помощью len(A), а также 
	min(A) и 
	max(A), если объекты, с которыми связаны ссылки можно сравнивать друг с другом. 
	
	Если присвоить один список другому, то тогда оба идентификатора станут указывать на один и тот же список.
	\begin{lstlisting}
		A = [1, 2, 3]
		B = A
		B[0] = 10		# B == [10, 2, 3] 
						# A == [10, 2, 3]
	\end{lstlisting}
	
	Данная особенность связывания справедлива и при вызове функций. Так если в объявлении функции изменить сам объект, то при выходе из нее он останется измененным.
	\begin{lstlisting}
		def f(B):
			B[0] = 10
		f(A)
		# B[0] == 10
	\end{lstlisting}
	Если же в объявлении функции изменяются только локальные списки, то ссылки на них теряются при выходе из функции. 
	\begin{lstlisting}
		def f(B):
			B = B[::-1]
		f(A)
	\end{lstlisting}
	В данном примере идентификатор B связывается сначала со списком, с которым уже связан А. По этой ссылке создается новый объект -- срез, и с ним связывается идентификатор В. Из-за этого ссылка на прежний объект теряется, и при выходе из функции список А остается неизменным.
	
	Еще один пример показывает, как можно добавить элемент в конец списка и как объединить несколько списков в один, сохраняя тот же порядок элементов, что и в исходных. 
	\begin{lstlisting}
		A = [1, 2, 3]
		B = A
		B.append(4)		# B == [1, 2, 3, 4]
		C = A + B		# C == [1, 2, 3, 4, 1, 2, 3, 4]
	\end{lstlisting}
	
	\subsection*{Копия списка}
	
	Создание копии списка можно проводить разными способами. Так, циклически пробежавшись по все элементам списка и добавив их в новый, получится копия прежнего. Однако то же самое можно сделать короче с использованием срезов.  
	\begin{lstlisting}
		B = []
		for x in A:
			B.append(x)
		# shorter
		B = A[:]
	\end{lstlisting}
	
	Если необходимо обезопасить список от изменения после выполнения какой-либо функции, то разумно передавать ей не сам список, а его срез.
	Т.е. вместо f(A) писать f(A[:]).
	
	
	
	
	
	
	\subsection*{Присваивание в срез списка}
	
	% 51:30
	Присваивание в срез с двумя параметрами никогда не приводит к ошибке. В следующем примере элементы массива, начиная с позиции 1 до элемента с позицией 3, вырезаются, а на их место вставляется другой фрагмент.
	\begin{lstlisting}
		A = [0, 1, 2, 3, 4]
		A[1:3] = [10, 20, 30]		# A == [0, 10, 20, 30, 3, 4]
		A[1:4] = []					# A == [0, 3, 4]
	\end{lstlisting}
	Присваивание же в срез с тремя параметрами может привести к ошибке, если размер присваиваемого списка не является подходящим (не укладывается в исходном списке с заданным шагом) 
	\begin{lstlisting}
		A = [0, 1, 2, 3, 4]
		A[1:5:2] = [10, 20]				# A == [0, 10, 2, 20, 4]
		A[1:5:2] = [10, 20, 30]			# Error!	
	\end{lstlisting}
	Также имеется возможность вставки фрагмента между соседними элементами исходного списка.
	\begin{lstlisting}
		A = [1, 2, 3]
		A[1:1] = [5, 6]			# A == [1, 5, 6, 2, 3]
	\end{lstlisting}
	Следующий пример показывает, как с помощью присваивания в срез можно создавать списки с довольно сложным порядком следования элементов.
	\begin{lstlisting}
		# [1, 6, 2, 5, 3, 4]
		A = [0]*6				# A == [0, 0, 0, 0, 0, 0]
		A[::2] = [1, 2, 3]
		A[::-2] = [4, 5, 6]
	\end{lstlisting}
	
	
	
	\subsection*{Обращение списка}
	
	В некоторых случаях списки бывают достаточно большими и на их обращение с помощью создания среза может не хватить памяти.  
	\begin{lstlisting}
		A = list(map(int, input().split()))
		i = 0
		while i < len(A) // 2:
			tmp = A[i]
			A[i] = A[-1-i]
			A[-1-i] = tmp
	\end{lstlisting}
	Данный алгоритм прост. Для его понимания достаточно заметить, что отрицательный индекс означает перебор элементов списка от последнего (-1) к первому (-n) и что исходный список обходится только до половины, так как иначе новый список был бы обращен в прежний.
	
	\subsection*{Циклический сдвиг}
	
	% 1:05:00
	Зачастую в некоторых задачах требуется осуществить циклический сдвиг элементов в списке. Так, при сдвиге влево необходимо  сначала сохранить первый элемент, чтобы потом, после работы цикла, поставить его на последнее место.
	\begin{lstlisting}
		A = [0, 1, 2, 3, 4]
		tmp = A[0]
		for i in range(0, len(A) - 1):
			A[i] = A[i+1]
		A[-1] = tmp
		# A == [1, 2, 3, 4, 0]
	\end{lstlisting}
	При наличии необходимой памяти, то же самое можно проделать с помощью срезов.
	\begin{lstlisting}
		A[:] = A[1:] + A[0:1]
	\end{lstlisting}
	
	\subsection*{Кортежи}
	
	В отличие от списков \emph{кортежи} являются неизменяемыми. В следующем примере показано, как объявить кортеж и как создать пустой. Важно отметить, что для устранения путаницы с переменными числового типа вводится специальная форма записи кортежа из одного элемента.
	\begin{lstlisting}
		A = 1, 2, 3, 4, 5		# type(A) == class<tuple>
		A = ()					# empty tuple
		A = 1					# type(A) == int
		A = (1, )				# type(A) == class<tuple>
	\end{lstlisting}
	
	
\end{document}